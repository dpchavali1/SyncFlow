# Universal Contacts Sync Design

## Goals
1. Treat `users/{uid}/contacts` as the single universal source-of-truth so Android, macOS, and Web always share the same schema.  
2. Preserve the original Android contact photo whenever it exists so every client can show avatars.  
3. Let desktop/web edits flow back to Android while keeping Android-origin data (phone number, normalized key, photo) intact.

## Schema
Each contact record now follows the same structure on every platform:

```
users/{uid}/contacts/{contactId} = {
  displayName: string,
  phoneNumbers: {
    "normalizedOrRaw": {
      number: string,
      normalizedNumber: string,
      type: string,
      label: string,
      isPrimary: boolean
    }
  },
  emails?: {
    "lowercasedEmail": {
      address: string,
      type: string,
      isPrimary: boolean
    }
  },
  notes?: string,
  photo: {
    thumbnailBase64?: string,  // populated by Android when a contact photo exists
    hash?: string,             // SHA-1 of the base64 blob (Android, desktop/web keep it updated)
    updatedAt?: timestamp      // updated only when the photo data changes
  },
  sync: {
    lastUpdatedAt: timestamp,
    lastUpdatedBy: "android" | "macos" | "web",
    version: number,
    pendingAndroidSync: boolean,
    desktopOnly: boolean,
    lastSyncedAt?: timestamp
  },
  sources: {
    android: boolean,
    macos: boolean,
    web: boolean
  },
  androidContactId?: number
}
```

The `contactId` is generated by `PhoneNumberNormalizer.getDeduplicationKey` so the normalized phone number drives deduping (name-only fallbacks exist for edge cases).

## Flow
1. **Android → Firebase**: `ContactsSyncService` reads the Contacts provider (name, phone, normalized number, contact photo, first email, first note) and writes the record above. Photos are converted to Base64 thumbnails and hashed so clients can detect changes.
2. **macOS/Web edits**: UI flows call `FirebaseService.create/updateContact` or `web/lib/firebase.create/updateContact`. They reuse the same schema, only altering `notes`, `emails`, and `displayName`/`phoneNumbers`. Crucially, when no new photo is provided the existing `photo.thumbnailBase64` stays untouched so Android avatars are preserved.
3. **Firebase → Android**: `ContactsReceiveService` listens for `sync.pendingAndroidSync = true` records, downloads the latest schema, and writes it back to the Android Contacts provider. It prefers the stored `androidContactId` but falls back to a number-based lookup. Updated display names, emails, notes, and photos are applied, then `markPendingSyncComplete` resets the sync flags.

## Photo handling
- Android is the canonical owner of contact photos. When a contact has a photo, Android encodes it, sets `photo.thumbnailBase64`, and keeps `photo.hash` + `photo.updatedAt` in sync.
- Desktop/web payload builders now treat `photo` as read-only unless a new Base64 blob is supplied (or an explicit empty string is passed to clear it). That prevents unintentional deletions while still allowing future UI to change avatars.
- `ContactsReceiveService` applies the latest `photo.thumbnailBase64` by updating/inserting the `Photo` row in the Contacts provider so Android shows the expected avatar.

## Conflict management
- Each update increments `sync.version` and stamps `sync.lastUpdatedAt`.  
- `sync.pendingAndroidSync` is set to `true` whenever desktop/web writes data so the Android listener picks it up.  
- `lastUpdatedBy` tells Android whether to skip its own writes.  
- The Android receiver favors `androidContactId` when available, then the normalized phone number, ensuring updates target the correct rows.

## Next steps
- Keep this schema in sync with any future clients (mobile, other desktop apps).  
- If we expose a photo-edit UI on desktop/web, pass an explicit (possibly empty) `photoBase64` so the receiver can add or clear the avatar.
